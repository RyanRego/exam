library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity modn IS
    generic(n : integer := 128);
    port(
        clk  : in std_logic;
        rst  : in std_logic;
        dout : out std_logic_vector(6 downto 0)
    );
end modn;

architecture Behavioral of modn is
    signal temp : std_logic_vector(22 downto 0);
    signal sclk : std_logic;
begin

    p11: process(clk, rst)
    begin
        if rst = '1' then
            temp <= (others => '0');
        elsif rising_edge(clk) then
            temp <= temp + 1;
        end if;
    end process;
    
    sclk <= temp(22);

    counter : process(sclk, rst)
        variable m : integer range 0 to (n-1) := 0;
    begin
        if rst = '1' then
            m := 0;
        elsif rising_edge(sclk) then
            m := m + 1;
        end if;

        if m = n then
            m := 0;
        end if;

        dout <= conv_std_logic_vector(m, 7);
    end process counter;

end Behavioral;


architecture behavior of modn is

--component
--signals
--uut

component modn
port(
    clk: 
    reset:
    dout:
);
end component;


initializing signals and variables := 
signal sclk: std_logic := 0;
signal reset: std_logic := 0;


